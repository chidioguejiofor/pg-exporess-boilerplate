import { tokenManagerStub } from "__tests__/unit/stubs";
import { parameterized } from "__tests__/utils";
import { expect } from "chai";
import { InvalidToken } from "errors";
import { LoginUserUsecase } from "../login-user";

const loginUserUsecase = new LoginUserUsecase(tokenManagerStub);

const validInput = {
  host: "localhost:3000",
  idToken: "some_token",
  network: "google" as const,
};

const validDecodedGooogleToken = {
  email: "mock@company1.com",
  name: "John Mock",
  aud: "client-instance-1",
  emailIsVerified: true,
  iss: "https://accounts.google.com",
};

const validDecodedMicrosoftToken = {
  email: "mock@company1.com",
  name: "John Mock",
  aud: "micro-instance-1",
  emailIsVerified: true,
  iss: "",
};

const validDecodedToken = {
  microsoft: validDecodedMicrosoftToken,
  google: validDecodedGooogleToken,
};

describe("LoginUserUsecase", () => {
  afterEach(() => {
    tokenManagerStub.generateToken.reset();
  });

  parameterized(
    "should throw InvalidToken error when user token is invalid when validation fails for",
    ["google", "microsoft"],
    async (network) => {
      tokenManagerStub.validateToken.throws(new InvalidToken());

      await expect(
        loginUserUsecase.execute({ ...validInput, network })
      ).to.be.rejectedWith(InvalidToken);
      tokenManagerStub.validateToken.calledOnceWith(network, "some_token");
    }
  );

  parameterized(
    "should return the user details and token when the login was successful",
    ["google", "microsoft"],
    async (network) => {
      const mockToken = "dummy_token";
      tokenManagerStub.validateToken.returns(validDecodedToken[network]);
      tokenManagerStub.generateToken.returns(Promise.resolve(mockToken));

      await expect(
        loginUserUsecase.execute({
          ...validInput,
          network,
        })
      ).to.eventually.eqls({
        user: {
          email: validDecodedGooogleToken.email,
          host: "localhost:3000",
        },
        token: mockToken,
      });

      tokenManagerStub.validateToken.calledOnceWith("google", "some_token");
    }
  );

  parameterized(
    "should return the user details and token when the login was successful",
    ["google", "microsoft"],
    async (network) => {
      const decodedToken = {
        ...validDecodedToken[network],
        aud: "invalid-client-id",
      };
      tokenManagerStub.validateToken.returns(decodedToken);

      await expect(
        loginUserUsecase.execute({ ...validInput })
      ).to.be.rejectedWith(InvalidToken);
    }
  );

  it("should throw error when  google has not yet verified the user account", async () => {
    const decodedToken = {
      ...validDecodedGooogleToken,
      emailIsVerified: false,
    };
    tokenManagerStub.validateToken.returns(decodedToken);

    await expect(loginUserUsecase.execute(validInput)).to.be.rejectedWith(
      InvalidToken
    );
  });

  it("should throw an error when the token was not generated by google", async () => {
    const decodedToken = {
      ...validDecodedGooogleToken,
      iss: "https://nestle.com",
    };
    tokenManagerStub.validateToken.returns(decodedToken);

    await expect(loginUserUsecase.execute(validInput)).to.be.rejectedWith(
      InvalidToken
    );
  });

  parameterized(
    "should throw error when the email is not contained in the email list for ",
    ["google", "microsoft"],
    async (network) => {
      const decodedToken = {
        ...validDecodedToken[network],
        email: "unknown@email.com",
      };
      tokenManagerStub.validateToken.returns(decodedToken);

      await expect(
        loginUserUsecase.execute({ ...validInput, network })
      ).to.be.rejectedWith(InvalidToken);
    }
  );

  parameterized(
    "should generate a token using host name in client config user logs in with",
    ["google", "microsoft"],
    async (network) => {
      const mockToken = "dummy_token";
      tokenManagerStub.validateToken.returns(validDecodedToken[network]);
      tokenManagerStub.generateToken.returns(Promise.resolve(mockToken));
      await loginUserUsecase.execute({ ...validInput, network });

      tokenManagerStub.generateToken.should.have.been.calledOnceWith(
        "randomeKey1",
        {
          email: validDecodedToken[network].email,
          host: "localhost:3000",
        }
      );
    }
  );
});
